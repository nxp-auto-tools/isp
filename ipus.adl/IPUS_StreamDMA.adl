// *-*- c -*-******************************************************************
// *
// *  Copyright Freescale 2013, All rights reserved.
// *  Copyright NXP 2017, All rights reserved.
// * 
// *  SPDX-License-Identifier: BSD-3-Clause
// *
// ****************************************************************************
// /** \addtogroup Ipus
// *  Place the description of a module here.
// *  @{
// ****************************************************************************
// /** 
// *  
// *  \file      IPUS_StreamDMA.adl
// *  \author    Herrmann Stephan-R70157
// *  \date      \$Date: 2013/08/01 10:50:49 $
// *
// *  \internal
// *   language  ADL
// *   $Id: fsl_header.el,v 1.1 2013/09/15 10:50:49 stephanh Exp $
// ****************************************************************************

#include "IPUS_Defines.h"

define (arch = IPUS_StreamDMA) {

  /// Start next line
  void StreamDMAStartLine() {
    int i;

    for (i=0; i< INPUT_STREAMS; i++) {
      S_CURRCHCFG_INA(i)=S_CHCFG_INA(i);
    }
#ifdef HASINB
    for (i=0; i< INPUT_STREAMS; i++) {
      S_CURRCHCFG_INB(i)=S_CHCFG_INB(i);
    }
#endif
#ifdef HASINALPHA
    for (i=0; i< INPUT_STREAMS; i++) {
      S_CURRCHCFG_INAL(i)=S_CHCFG_INAL(i);
    }
#endif

    for (i=0; i< INPUT_STREAMS; i++) {
      S_CURRLINE_PTR_INA(i)=S_LINE_PTR_INA(i);
    }
#ifdef HASINB

    for (i=0; i< INPUT_STREAMS; i++) {
      S_CURRLINE_PTR_INB(i)=S_LINE_PTR_INB(i);
    }
#endif
#ifdef HASINALPHA
    for (i=0; i< INPUT_STREAMS; i++) {
      S_CURRLINE_PTR_INAL(i)=S_LINE_PTR_INAL(i);
    }
#endif

    for (i=0; i< INPUT_STREAMS; i++) {
      S_CURRLINELEN_INA(i)=S_LINELEN_INA(i);
    }
#ifdef HASINB
    for (i=0; i< INPUT_STREAMS; i++) {
      S_CURRLINELEN_INB(i)=S_LINELEN_INB(i);
    }
#endif
#ifdef HASINALPHA
    for (i=0; i< INPUT_STREAMS; i++) {
      S_CURRLINELEN_INAL(i)=S_LINELEN_INAL(i);
    }
#endif

    for (i=0; i< INPUT_STREAMS; i++) {  // reset Stream DMA counters
      I_RPTCNT_INA(i)=S_CURRCHCFG_INA(i)(19,18); // RPT;
    }
#ifdef HASINB
    for (i=0; i< INPUT_STREAMS; i++) {  // reset Stream DMA counters
      I_RPTCNT_INB(i)=S_CURRCHCFG_INB(i)(19,18); // RPT;
    }
#endif
#ifdef HASINALPHA
    for (i=0; i< INPUT_STREAMS; i++) {  // reset Stream DMA counters
      I_RPTCNT_INAL(i)=S_CURRCHCFG_INAL(i)(19,18);
    }
#endif

    for (i=0; i< INPUT_STREAMS; i++) {  // reset Stream DMA counters
      I_POS_INA(i)=0 - S_CURRCHCFG_INA(i)(26,24); // REPLACEWIDTH;
    }
#ifdef HASINB
    for (i=0; i< INPUT_STREAMS; i++) {  // reset Stream DMA counters
      I_POS_INB(i)=0 - S_CURRCHCFG_INB(i)(26,24); // REPLACEWIDTH;
    }
#endif
#ifdef HASINALPHA
    for (i=0; i< INPUT_STREAMS; i++) {  // reset Stream DMA counters
      I_POS_INAL(i)=0 - S_CURRCHCFG_INAL(i)(26,24);
    }
#endif

    for (i=0; i< OUTPUT_STREAMS; i++) {
      S_CURRCHCFG_OUT(i)=S_CHCFG_OUT(i);
    }

    for (i=0; i< OUTPUT_STREAMS; i++) {
      S_CURRLINE_PTR_OUT(i)=S_LINE_PTR_OUT(i);
    }

    for (i=0; i< OUTPUT_STREAMS; i++) {
      S_CURRLINELEN_OUT(i)=S_LINELEN_OUT(i);
    }

    for (i=0; i< OUTPUT_STREAMS; i++) {
      I_POS_OUT(i)=0;
    }

    for (i=0; i< OUTPUT_STREAMS; i++) {
      I_SKIPCNT_OUT(i)=0;
    }
  }

// ****************************************************************************
// *  Registers
// ****************************************************************************

#ifndef MAKEDOC
  define (reg=S_EMUMEM) {
    """
    Internal Register:
    Emunlate memory for input interface
    """;
    width = 1; // internal signed value, 8 bit resolution
    reset = 0;
  }
#endif // MAKEDOC

#ifndef STREAM_IPS_IN_IPU
  define (reg=S_CFG) {
    """
    StreamDMA Host Register:
    Channel enable bits
    """;
    width = 32;
    define (field=OUT3) {
      """
      OUT line 3 enabled (for OUT[3])
      """;
      bits = (27,27);
    }
    define (field=OUT2) {
      """
      OUT line 2 enabled (for OUT[2])
      """;
      bits = (26,26);
    }
    define (field=OUT1) {
      """
      OUT line 1 enabled (for OUT[1])
      """;
      bits = (25,25);
    }
    define (field=OUT0) {
      """
      OUT line 0 enabled (for OUT[0])
      """;
      bits = (24,24);
    }
    define (field=ALPHA2) {
      """
      INAlpha line 2 enabled (for INAlpha[6] to INAlpha[8])
      """;
      bits = (18,18);
    }
    define (field=ALPHA1) {
      """
      INAlpha line 1 enabled (for INAlpha[3] to INAlpha[5])
      """;
      bits = (17,17);
    }
    define (field=ALPHA0) {
      """
      INAlpha line 0 enabled (for INAlpha[0] to INAlpha[2])
      """;
      bits = (16,16);
    }
    define (field=INB2) {
      """
      INB line 2 enabled (for INB[6] to INB[8])
      """;
      bits = (10,10);
    }
    define (field=INB1) {
      """
      INB line 1 enabled (for INB[3] to INB[5])
      """;
      bits = (9,9);
    }
    define (field=INB0) {
      """
      INB line 0 enabled (for INB[0] to INB[2])
      """;
      bits = (8,8);
    }
    define (field=INA2) {
      """
      INA line 2 enabled (for INA[6] to INA[8])
      """;
      bits = (2,2);
    }
    define (field=INA1) {
      """
      INA line 1 enabled (for INA[3] to INA[5])
      """;
      bits = (1,1);
    }
    define (field=INA0) {
      """
      INA line 0 enabled (for INA[0] to INA[2])
      """;
      bits = (0,0);
    }
    define (read) {
      action = {
        bits<32> retval;
        retval=0;
        retval( 2, 0)=S_CHANNELS_INA;
#ifdef HASINB
        retval(10, 8)=S_CHANNELS_INB;
#endif
#ifdef HASINALPHA
        retval(18,16)=S_CHANNELS_INAL;
#endif
        retval(27,14)=S_CHANNELS_OUT;
        return retval;
      };
    }
    define (write) {
      action = func (bits<32> val) {
        S_CHANNELS_INA=val( 2, 0);
#ifdef HASINB
        S_CHANNELS_INB=val(10, 8);
#endif
#ifdef HASINALPHA
        S_CHANNELS_INAL=val(18,16);
#endif
        S_CHANNELS_OUT=val(27,24);
      };
    }
  } 
#endif

#ifdef SYSC
  define (reg=SysC_StreamDMA_Channel) {
    """
    SystemC simulator register (make un-architected register)
    channel number of stream dma access

    +  -1 no streamDMA access
    + 0-3 write: StreamDMA write channel
    + 0-2 read:  StreamDMA read channel of INA
    + 3-5 read:  StreamDMA read channel of INB
    + 6-8 read:  StreamDMA read channel of INAlpha
    """;
    width = 32;
  }
#endif


  // Stream Parameters for INA ***************
#ifndef STREAM_IPS_IN_IPU
  define (reg=S_CHANNELS_INA) {
    """
    StreamIF Host Register:
    Enabled Lines for channel INA
    """;
    width = 3;
  }
#endif

  define (regfile=S_LINE_PTR_INA) {
    """
    StreamIF Host Register:
    Line Start Addresses
    """;
    width = 32;
    size  = INPUT_STREAMS;
  }

  define (regfile=S_CURRLINE_PTR_INA) {
    """
    StreamIF Host Register:
    Active Line Start Addresses (read only)
    """;
    width = 32;
    size  = INPUT_STREAMS;
  }

  define (regfile=S_LINELEN_INA) {
    """
    StreamIF Host Register:
    Line length in pixels
    """;
    width = 16;   // unsigned value
    size  = INPUT_STREAMS;
    reset = 0xFFFF;
  }

  define (regfile=S_CURRLINELEN_INA) {
    """
    StreamIF Host Register:
    Active line length in pixels (read only)
    """;
    width = 16;   // unsigned value
    size  = INPUT_STREAMS;
    reset = 0xFFFF;
  }

  define (regfile=S_CHCFG_INA) {
    """
    StreamIF Host Register:
    Configuration for input streams at INA of next line to be processed.
    """;
    width = 32;
    reset = 0x50000;
    size  = INPUT_STREAMS;
    define (field=REPLACEVALUE) {
      """
      Value to use for pixels outside the valid image area
      """;
      bits = (15,0);
    }
    define (field=STEP) {
      """
      Offset between two pixels being presented to the IPU engine

      + 0: 4 pixels offset
      + 1: 1 pixel offset (no pixel is skipped, all pixels are exercised)
      + 2: 2 pixels offset
      + 3: 3 pixels offset
      """;
      bits = (17,16);
    }
    define (field=RPT) {
      """
      How often a pixel is presented to the IPU engine

      + 0: 4 times
      + 1: 1 time (increment each pixel)
      + 2: 2 times
      + 3: 3 times
      """;
      bits = (19,18);
    }
    define (field=REPLACEMODE) {
      """
      Scheme for which pixels are getting the REPLAVEVALUE

      + 0: outside pixel = REPLACEVALUE, inside pixel = pixel value
      + 1: outside pixel = copy pixel from boundary, inside pixels = pixel value
      + 2: reserved
      + 3: outside pixel = REPLACEVALUE, inside pixels = REPLACEVALUE
      + 4: outside pixel = 0 , inside pixels = REPLACEVALUE
      """;
      // + 2: not implemented: outside pixel = repeat boundary
      // with width; inside pxel = pixel value
      bits = (22,20);
    }
    define (field=REVERSE) {
      """
      Do reverse scan of the line 

      + 0: normal scan (left to right)
      + 1: reverse scan (right to left)
      """;
      bits = (23,23);
    }
    define (field=REPLACEWIDTH) {
      """
      How many pixels are assumed at the beginning of the line outside
      the image. This might be used for filters with horizontal neighborhood.
      Example: 

      + 0: the image is not extended at the beginning of the line
           (first pixels is valid)
      + n: will present n more pixels at the beginning of the line.
           The (n+1)th pixel is the first valid pixel. The n first pixels
           are treated according to the REPLACEMODE
      """;
      bits = (26,24);
    }
    define (field=TRANSFORM) {
      """
      Apply coordiante transformation mode
    
      + 0: linear scan
      + 1: transformation
      """;
      bits = (27,27);
    }
    define (field=BUFFERTYPE) {
      """
      Data type of memory buffer. The IPU will always get 16 bit values. 

      + 0: 16-bit
      + 1: 8-bit, data is put to MSBs
      + 2: 8-bit, data is put to LSBs
      """;
      bits = (29,28);
    }
#ifdef LOG_MORE
    define (read) {
      action = func (unsigned line_no) { return S_CHCFG_INA(line_no);};
    }

    define (write) {
      action = func (unsigned line_no, bits<32> val) {
        S_CHCFG_INA(line_no)=val;
        info(1,"INA(",line_no,").REPEATVALUE = ",
             S_CHCFG_INA(line_no)(15,0));
        info(1,"INA(",line_no,").STEP = ",
             S_CHCFG_INA(line_no)(17,16));
        info(1,"INA(",line_no,").RPT = ",
             S_CHCFG_INA(line_no)(19,18));
        {
          static const char *mode[8] = {"0: outside const",
                                        "1: outside hold",
                                        "2: reseved",
                                        "3: repalce all w/ const",
                                        "4: inside const, outside 0",
                                        "5: reserved",
                                        "6: reserved",
                                        "7: reserved"};
          info(1,"INA(",line_no,").REPLACEMODE = ",
               mode[S_CHCFG_INA(line_no)(22,20).uint32()]);
        }
        info(1,"INA(",line_no,").REVERSE = ",
             S_CHCFG_INA(line_no)(23));
        info(1,"INA(",line_no,").REPLACEWIDTH = ",
             S_CHCFG_INA(line_no)(26,24));
        //info(1,"INA(",line_no,").TRANSFORM = ",
        //     S_CHCFG_INA(line_no)(27));
        //info(1,"INA(",line_no,").BUFFERTYPE = ",
        //     S_CHCFG_INA(line_no)(29,28));
        {
          static const char *mode[4] = {"0: 16bpp",
                                        "1: 8bpp to MSB",
                                        "2: 8bpp to LSB",
                                        "3: reserved"};
          info(1,"INA(",line_no,").BUFFERTYPE = ",
               mode[S_CHCFG_INA(line_no)(29,28).uint32()]);
        }
      };
    }
#endif
  }

  define (regfile=S_CURRCHCFG_INA) {
    """
    StreamIF Host Register:
    Active configuration status for input streams at INA (read onyl)
    """;
    width = 32;
    size=INPUT_STREAMS;
    define (field=REPLAVEVALUE) {
      """
      Value to use for pixels outside the valid image area
      """;
      bits = (15,0);
    }
    define (field=STEP) {
      """
      Offset between two pixels being presented to the IPU engine

      + 0: 4 pixels offset
      + 1: 1 pixel offset (no pixel is skipped, all pixels are exercised)
      + 2: 2 pixels offset
      + 3: 3 pixels offset
      """;
      bits = (17,16);
    }
    define (field=RPT) {
      """
      How often a pixel is presented to the IPU engine

      + 0: 4 times
      + 1: 1 time (increment each pixel)
      + 2: 2 times
      + 3: 3 times
      """;
      bits = (19,18);
    }
    define (field=REPLACEMODE) {
      """
      Scheme for which pixels are getting the REPLAVEVALUE

      + 0: outside pixel = REPLACEVALUE, inside pixel = pixel value
      + 1: outside pixel = copy pixel from boundary, inside pixels = pixel value
      + 2: reserved
      + 3: outside pixel = REPLACEVALUE, inside pixels = REPLACEVALUE
      + 4: outside pixel = 0 , inside pixels = REPLACEVALUE
      """;
      //      + 2: not implemented: outside pixel = repeat boundary with width; inside pxel = pixel value
      bits = (22,20);
    }
    define (field=REVERSE) {
      """
      Do reverse scan of the line 

      + 0: normal scan (left to right)
      + 1: reverse scan (right to left)
      """;
      bits = (23,23);
    }
    define (field=REPLACEWIDTH) {
      """
      How many pixels are assumed at the beginning of the line outside
      the image. This might be used for filters with horizontal neighborhood.
      Example: 

      + 0: the image is not extended at the beginning of the line
           (first pixels is valid)
      + n: will present n more pixels at the beginning of the line.
           The (n+1)th pixel is the first valid pixel. The n first pixels
           are treated according to the REPLACEMODE
      """;
      bits = (26,24);
    }
    define (field=TRANSFORM) {
      """
      Apply coordiante transformation mode
    
      + 0: linear scan
      + 1: transformation
      """;
      bits = (27,27);
    }
    define (field=BUFFERTYPE) {
      """
      Data type of memory buffer. The IPU will always get 16 bit values. 

      + 0: 16-bit
      + 1: 8-bit, data is put to MSBs
      + 2: 8-bit, data is put to LSBs
      """;
      bits = (29,28);
    }

#ifdef LOG_MORE
    define (read) {
      action = func (unsigned line_no) { return S_CURRCHCFG_INA(line_no);};
    }

    define (write) {
      action = func (unsigned line_no, bits<32> val) {
        S_CURRCHCFG_INA(line_no)=val;
        info(1,"INA(",line_no,").REPEATVALUE = ",
             S_CURRCHCFG_INA(line_no)(15,0));
        info(1,"INA(",line_no,").STEP = ",
             S_CURRCHCFG_INA(line_no)(17,16));
        info(1,"INA(",line_no,").RPT = ",
             S_CURRCHCFG_INA(line_no)(19,18));
        {
          static const char *mode[8] = {"0: outside const",
                                        "1: outside hold",
                                        "2: reseved",
                                        "3: repalce all w/ const",
                                        "4: inside const, outside 0",
                                        "5: reserved",
                                        "6: reserved",
                                        "7: reserved"};
          info(1,"INA(",line_no,").REPLACEMODE = ",
               mode[S_CURRCHCFG_INA(line_no)(22,20).uint32()]);
        }
        //switch (S_CURRCHCFG_INA(line_no)(22,20).uint32()) {
        //case 0:
        //  info(1,"INA(",line_no,").REPLACEMODE = ",
        //       "outside const");
        //  break;
        //case 1:
        //  info(1,"INA(",line_no,").REPLACEMODE = ",
        //       "outside hold");
        //  break;
        //case 3:
        //  info(1,"INA(",line_no,").REPLACEMODE = ",
        //       "repalce all w/ const");
        //  break;
        //case 4:
        //  info(1,"INA(",line_no,").REPLACEMODE = ",
        //       "inside const, outside 0");
        //  break;
        //case 2:
        //default:
        //  info(1,"INA(",line_no,").REPLACEMODE = ",
        //       "reserved");
        //  break;
        //}
        info(1,"INA(",line_no,").REVERSE = ",
             S_CURRCHCFG_INA(line_no)(23));
        info(1,"INA(",line_no,").REPLACEWIDTH = ",
             S_CURRCHCFG_INA(line_no)(26,24));
        //info(1,"INA(",line_no,").TRANSFORM = ",
        //     S_CURRCHCFG_INA(line_no)(27));
        //info(1,"INA(",line_no,").BUFFERTYPE = ",
        //     S_CURRCHCFG_INA(line_no)(29,28));
        {
          static const char *mode[4] = {"0: 16bpp",
                                        "1: 8bpp to MSB",
                                        "2: 8bpp to LSB",
                                        "3: reserved"};
          info(1,"INA(",line_no,").BUFFERTYPE = ",
               mode[S_CURRCHCFG_INA(line_no)(29,28).uint32()]);
        }
      };
    }
#endif
  }

  define (regfile=I_RPTCNT_INA) {
    """
    Internal Register:
    counting the repeat status
    """;
    width = 2;
    reset = 1;
    size  = INPUT_STREAMS;
    define (read) {
      action = func (unsigned line_no) {
        if (I_RPTCNT_INA(line_no) == 0) return 4;
        return I_RPTCNT_INA(line_no);
      };
    }
  }

  define (regfile=I_POS_INA) {
    """
    Internal Register:
    Current pixel position in the line
    """;
    width = 18; // internal signed value, 8 bit resolution
    size  = INPUT_STREAMS;
  }

  // do stream in for INA
  define (regfile=P_INA) {
    """
    Internal Register:
    Prefetch Register for INA StreamDMA input. Once data is
    moved to INA, the StreamDMA engine will autonomously fill
    the register with the next value from the line.
    """;
    width = 16; // internal signed value, 8 bit resolution
    size  = INPUT_STREAMS;
#ifndef MAKEDOC
    pseudo = true;
    define (read) {
      action = func(unsigned line_no) {
        bits<32> cfg;
        bits<16> retval;
        bits<32> addr;
        bits<1>  odd_byte;
        int len,pos,step;
        int lineend;
        int offset;
        int wordsize;

        cfg=S_CURRCHCFG_INA(line_no);
        wordsize=(cfg(29,28) == 0)? 2 : 1; // BUFFERTYPE
        len=S_CURRLINELEN_INA(line_no).uint32()-1;
        pos=I_POS_INA(line_no).int32();
        step=cfg(17,16).uint32(); //STEP
        if (!step) step=4;
        //replacemode=cfg(22,20).uint32();
        lineend= (pos > len)? 1 : 0;

#ifndef SYSC
#ifdef LOG_MORE
         // unconfigured input address
        if ((cfg(22,20).uint32() < 3) &&
            (S_CURRLINE_PTR_INA(line_no).uint32() < 0x10000)) {
          error(1,
                "\n********************\n",
                "ERROR: invalid address INA_PTR(",
                line_no,") = ",S_CURRLINE_PTR_INA(line_no),
                "\n********************\n");
        }
#endif
#endif

        if (S_EMUMEM == 1) {  // do not implemnt this branch in HW!!!
          retval=I_POS_INA(line_no);
        }
        else {

          offset=pos;
          if (cfg(23)==1) {  // REVERSE
            offset=len - offset;
          };
#ifdef LOG_MORE
          info (1,"POS_INA line",line_no," = ", pos);
#endif
          switch (cfg(22,20).uint32() ) { //REPLACEMODE
          case 0:   // normal with pad to constant (hold order 0)
            if ((offset<0)  || (offset > len)) {
              odd_byte=0;
              retval = cfg(15,0); // REPLACEVALUE
            }
            else {
              //repalced=0;
              addr=S_CURRLINE_PTR_INA(line_no)+(offset*wordsize);
              // for byte selection from word
              odd_byte=addr(0);
              // do word read always and then select later the right byte lane
              addr(0)=0;

#ifdef SYSC
              SysC_StreamDMA_Channel=line_no;
#endif
              retval=Mem(addr,2);
#ifdef SYSC
              SysC_StreamDMA_Channel=-1;
#endif
            }
            break;
          case 1:  // normal mode, pad with nearest valid pixel (hold order 1)
            //padstart=padend=0;
            if (offset<0) {
              offset=0;
            }
            if (offset>len) {
              offset= len;   // last valid pixel
            }
            addr=S_CURRLINE_PTR_INA(line_no)+(offset*wordsize);
            // for byte selection from word
            odd_byte=addr(0);
            // do word read always and then select later the right byte lane
            addr(0)=0;
#ifdef SYSC
            SysC_StreamDMA_Channel=line_no;
#endif
            retval=Mem(addr,2);
#ifdef SYSC
            SysC_StreamDMA_Channel=-1;
#endif
            break;

          case 3:  // constant
            odd_byte=0;
            retval=cfg(15,0); // REPLACEVALUE
            break;
          default: // constant for valid, 0 for invalid
            odd_byte=0;
            if ((offset<0)  || (offset > len)) {
              retval=0;
            }
            else {
              retval=cfg(15,0); // REPLACEVALUE
            }
          }

          // 8 bit alignment
          if (wordsize == 1) {
            if (odd_byte == 1) {
              retval(7,0)=retval(15,8);    // odd address in MSBs?
            }
            else {
              retval(15,8) = retval(7,0);  // even address in LSBs
            }
            if (cfg(29,28) == 1) {
              //BUFFERTYPE = 8bit MSB
              retval(7,0)=0;
            }
            else {  //BUFFERTYPE = 8bit LSB
              retval(15,8)=0;
            }
          }
        }


        if (I_RPTCNT_INA(line_no) == 1) {
          if (lineend  == 0) { // stop incrementing after line end
            I_POS_INA(line_no) = pos + step;
            I_RPTCNT_INA(line_no) = cfg(19,18); //RPT
          }
        }
        else {
          I_RPTCNT_INA(line_no) = I_RPTCNT_INA(line_no) -1;
        }
        return retval;

      };
    }
    define (write) {
      action = func(unsigned line_no, bits<16> OUT) {
        return;
      };
    }
#endif // MAKEDOC
  }

#ifdef HASINB
  // Stream Parameters for INB ***************
#ifndef STREAM_IPS_IN_IPU
  define (reg=S_CHANNELS_INB) {
    """
    StreamIF Host Register:
    Enabled Lines for channel INB
    """;
    width = 3;
  }
#endif

  define (regfile=S_LINE_PTR_INB) {
    """
    StreamIF Host Register:
    Line Start Addresses
    """;
    width = 32;
    size  = INPUT_STREAMS;
  }

  define (regfile=S_CURRLINE_PTR_INB) {
    """
    StreamIF Host Register:
    Active Line Start Addresses (read only)
    """;
    width = 32;
    size  = INPUT_STREAMS;
  }

  define (regfile=S_LINELEN_INB) {
    """
    StreamIF Host Register:
    Line length in pixels
    """;
    width = 16;   // unsigned value
    size  = INPUT_STREAMS;
    reset = 0xFFFF;
  }

  define (regfile=S_CURRLINELEN_INB) {
    """
    StreamIF Host Register:
    Active line length in pixels (read only)
    """;
    width = 16;   // unsigned value
    size  = INPUT_STREAMS;
    reset = 0xFFFF;
  }

  define (regfile=S_CHCFG_INB) {
    """
    StreamIF Host Register:
    Configuration for input streams at INB of next line to be processed.
    """;
    width = 32;
    reset = 0x50000;
    size  = INPUT_STREAMS;
    define (field=REPLACEVALUE) {
      """
      Value to use for pixels outside the valid image area
      """;
      bits = (15,0);
    }
    define (field=STEP) {
      """
      Offset between two pixels being presented to the IPU engine

      + 0: 4 pixels offset
      + 1: 1 pixel offset (no pixel is skipped, all pixels are exercised)
      + 2: 2 pixels offset
      + 3: 3 pixels offset
      """;
      bits = (17,16);
    }
    define (field=RPT) {
      """
      How often a pixel is presented to the IPU engine

      + 0: 4 times
      + 1: 1 time (increment each pixel)
      + 2: 2 times
      + 3: 3 times
      """;
      bits = (19,18);
    }
    define (field=REPLACEMODE) {
      """
      Scheme for which pixels are getting the REPLAVEVALUE

      + 0: outside pixel = REPLACEVALUE, inside pixel = pixel value
      + 1: outside pixel = copy pixel from boundary, inside pixels = pixel value
      + 2: reserved
      + 3: outside pixel = REPLACEVALUE, inside pixels = REPLACEVALUE
      + 4: outside pixel = 0 , inside pixels = REPLACEVALUE
      """;
      // + 2: not implemented: outside pixel = repeat boundary
      // with width; inside pxel = pixel value
      bits = (22,20);
    }
    define (field=REVERSE) {
      """
      Do reverse scan of the line 

      + 0: normal scan (left to right)
      + 1: reverse scan (right to left)
      """;
      bits = (23,23);
    }
    define (field=REPLACEWIDTH) {
      """
      How many pixels are assumed at the beginning of the line outside
      the image. This might be used for filters with horizontal neighborhood.
      Example: 

      + 0: the image is not extended at the beginning of the line
           (first pixels is valid)
      + n: will present n more pixels at the beginning of the line.
           The (n+1)th pixel is the first valid pixel. The n first pixels
           are treated according to the REPLACEMODE
      """;
      bits = (26,24);
    }
    //define (field=TRANSFORM) {
    //  """
    //  Apply coordiante transformation mode
    //
    //  + 0: linear scan
    //  + 1: transformation
    //  """;
    //  bits = (27,27);
    //}
    define (field=BUFFERTYPE) {
      """
      Data type of memory buffer. The IPU will always get 16 bit values. 

      + 0: 16-bit
      + 1: 8-bit, data is put to MSBs
      + 2: 8-bit, data is put to LSBs
      """;
      bits = (29,28);
    }
#ifdef LOG_MORE
    define (read) {
      action = func (unsigned line_no) { return S_CHCFG_INB(line_no);};
    }

    define (write) {
      action = func (unsigned line_no, bits<32> val) {
        S_CHCFG_INB(line_no)=val;
        info(1,"INB(",line_no,").REPEATVALUE = ",
             S_CHCFG_INB(line_no)(15,0));
        info(1,"INB(",line_no,").STEP = ",
             S_CHCFG_INB(line_no)(17,16));
        info(1,"INB(",line_no,").RPT = ",
             S_CHCFG_INB(line_no)(19,18));
        {
          static const char *mode[8] = {"0: outside const",
                                        "1: outside hold",
                                        "2: reseved",
                                        "3: repalce all w/ const",
                                        "4: inside const, outside 0",
                                        "5: reserved",
                                        "6: reserved",
                                        "7: reserved"};
          info(1,"INB(",line_no,").REPLACEMODE = ",
               mode[S_CHCFG_INB(line_no)(22,20).uint32()]);
        }
        info(1,"INB(",line_no,").REVERSE = ",
             S_CHCFG_INB(line_no)(23));
        info(1,"INB(",line_no,").REPLACEWIDTH = ",
             S_CHCFG_INB(line_no)(26,24));
        //info(1,"INB(",line_no,").TRANSFORM = ",
        //     S_CHCFG_INB(line_no)(27));
        //info(1,"INB(",line_no,").BUFFERTYPE = ",
        //     S_CHCFG_INB(line_no)(29,28));
        {
          static const char *mode[4] = {"0: 16bpp",
                                        "1: 8bpp to MSB",
                                        "2: 8bpp to LSB",
                                        "3: reserved"};
          info(1,"INB(",line_no,").BUFFERTYPE = ",
               mode[S_CHCFG_INB(line_no)(29,28).uint32()]);
        }
      };
    }
#endif
  }

  define (regfile=S_CURRCHCFG_INB) {
    """
    StreamIF Host Register:
    Active configuration status for input streams at INB (read onyl)
    """;
    width = 32;
    size=INPUT_STREAMS;
    define (field=REPLAVEVALUE) {
      """
      Value to use for pixels outside the valid image area
      """;
      bits = (15,0);
    }
    define (field=STEP) {
      """
      Offset between two pixels being presented to the IPU engine

      + 0: 4 pixels offset
      + 1: 1 pixel offset (no pixel is skipped, all pixels are exercised)
      + 2: 2 pixels offset
      + 3: 3 pixels offset
      """;
      bits = (17,16);
    }
    define (field=RPT) {
      """
      How often a pixel is presented to the IPU engine

      + 0: 4 times
      + 1: 1 time (increment each pixel)
      + 2: 2 times
      + 3: 3 times
      """;
      bits = (19,18);
    }
    define (field=REPLACEMODE) {
      """
      Scheme for which pixels are getting the REPLAVEVALUE

      + 0: outside pixel = REPLACEVALUE, inside pixel = pixel value
      + 1: outside pixel = copy pixel from boundary, inside pixels = pixel value
      + 2: reserved
      + 3: outside pixel = REPLACEVALUE, inside pixels = REPLACEVALUE
      + 4: outside pixel = 0 , inside pixels = REPLACEVALUE
      """;
      //      + 2: not implemented: outside pixel = repeat boundary with width; inside pxel = pixel value
      bits = (22,20);
    }
    define (field=REVERSE) {
      """
      Do reverse scan of the line 

      + 0: normal scan (left to right)
      + 1: reverse scan (right to left)
      """;
      bits = (23,23);
    }
    define (field=REPLACEWIDTH) {
      """
      How many pixels are assumed at the beginning of the line outside
      the image. This might be used for filters with horizontal neighborhood.
      Example: 

      + 0: the image is not extended at the beginning of the line
           (first pixels is valid)
      + n: will present n more pixels at the beginning of the line.
           The (n+1)th pixel is the first valid pixel. The n first pixels
           are treated according to the REPLACEMODE
      """;
      bits = (26,24);
    }
    //define (field=TRANSFORM) {
    //  """
    //  Apply coordiante transformation mode
    //
    //  + 0: linear scan
    //  + 1: transformation
    //  """;
    //  bits = (27,27);
    //}
    define (field=BUFFERTYPE) {
      """
      Data type of memory buffer. The IPU will always get 16 bit values. 

      + 0: 16-bit
      + 1: 8-bit, data is put to MSBs
      + 2: 8-bit, data is put to LSBs
      """;
      bits = (29,28);
    }

#ifdef LOG_MORE
    define (read) {
      action = func (unsigned line_no) { return S_CURRCHCFG_INB(line_no);};
    }

    define (write) {
      action = func (unsigned line_no, bits<32> val) {
        S_CURRCHCFG_INB(line_no)=val;
        info(1,"INB(",line_no,").REPEATVALUE = ",
             S_CURRCHCFG_INB(line_no)(15,0));
        info(1,"INB(",line_no,").STEP = ",
             S_CURRCHCFG_INB(line_no)(17,16));
        info(1,"INB(",line_no,").RPT = ",
             S_CURRCHCFG_INB(line_no)(19,18));
        {
          static const char *mode[8] = {"0: outside const",
                                        "1: outside hold",
                                        "2: reseved",
                                        "3: repalce all w/ const",
                                        "4: inside const, outside 0",
                                        "5: reserved",
                                        "6: reserved",
                                        "7: reserved"};
          info(1,"INB(",line_no,").REPLACEMODE = ",
               mode[S_CURRCHCFG_INB(line_no)(22,20).uint32()]);
        }
        info(1,"INB(",line_no,").REVERSE = ",
             S_CURRCHCFG_INB(line_no)(23));
        info(1,"INB(",line_no,").REPLACEWIDTH = ",
             S_CURRCHCFG_INB(line_no)(26,24));
        //info(1,"INB(",line_no,").TRANSFORM = ",
        //     S_CURRCHCFG_INB(line_no)(27));
        //info(1,"INB(",line_no,").BUFFERTYPE = ",
        //     S_CURRCHCFG_INB(line_no)(29,28));
        {
          static const char *mode[4] = {"0: 16bpp",
                                        "1: 8bpp to MSB",
                                        "2: 8bpp to LSB",
                                        "3: reserved"};
          info(1,"INB(",line_no,").BUFFERTYPE = ",
               mode[S_CURRCHCFG_INB(line_no)(29,28).uint32()]);
        }
      };
    }
#endif
  }

  define (regfile=I_RPTCNT_INB) {
    """
    Internal Register:
    counting the repeat status
    """;
    width = 2;
    reset = 1;
    size  = INPUT_STREAMS;
    define (read) {
      action = func (unsigned line_no) {
        if (I_RPTCNT_INB(line_no) == 0) return 4;
        return I_RPTCNT_INB(line_no);
      };
    }
  }

  define (regfile=I_POS_INB) {
    """
    Internal Register:
    Current pixel position in the line
    """;
    width = 18; // internal signed value, 8 bit resolution
    size  = INPUT_STREAMS;
  }

  // do stream in for INB
  define (regfile=P_INB) {
    """
    Internal Register:
    Prefetch Register for INB StreamDMA input. Once data is
    moved to INB, the StreamDMA engine will autonomously fill
    the register with the next value from the line.
    """;
    width = 16; // internal signed value, 8 bit resolution
    size  = INPUT_STREAMS;
#ifndef MAKEDOC
    pseudo = true;
    define (read) {
      action = func(unsigned line_no) {
        bits<32> cfg;
        bits<16> retval;
        bits<32> addr;
        bits<1>  odd_byte;
        int len,pos,step;
        int lineend;
        int offset;
        int wordsize;

        cfg=S_CURRCHCFG_INB(line_no);
        wordsize=(cfg(29,28) == 0)? 2 : 1; // BUFFERTYPE
        len=S_CURRLINELEN_INB(line_no).uint32()-1;
        pos=I_POS_INB(line_no).int32();
        step=cfg(17,16).uint32(); //STEP
        if (!step) step=4;
        lineend= (pos > len)? 1 : 0;

#ifndef SYSC
#ifdef LOG_MORE
         // unconfigured output address
        if ((cfg(22,20).uint32() < 3) &&
            (S_CURRLINE_PTR_INB(line_no).uint32() < 0x10000)) {
          error(1,
                "\n********************\n",
                "ERROR: invalid address INB_PTR(",
                line_no,") = ",S_CURRLINE_PTR_INB(line_no),
                "\n********************\n");
        }
#endif
#endif

        if (S_EMUMEM == 1) {  // do not implemnt this branch in HW!!!
          retval=I_POS_INB(line_no);
        }
        else {

          offset=pos;
          if (cfg(23)==1) {  // REVERSE
            offset=len - offset;
          };

          switch (cfg(22,20).uint32() ) { //REPLACEMODE
          case 0:   // normal with pad to constant (hold order 0)
            if ((offset<0)  || (offset > len)) {
              odd_byte=0;
              retval =  cfg(15,0); // REPLACEVALUE
            }
            else {
              addr=S_CURRLINE_PTR_INB(line_no)+(offset*wordsize);
            // for byte selection from word
            odd_byte=addr(0);
            // do word read always and then select later the right byte lane
            addr(0)=0;
#ifdef SYSC
              SysC_StreamDMA_Channel=line_no+3;
#endif
              retval=Mem(addr,2);
#ifdef SYSC
              SysC_StreamDMA_Channel=-1;
#endif
            }
            break;
          case 1:  // normal mode, pad with nearest valid pixel (hold order 1)
            if (offset<0) {
              offset=0;
            }
            if (offset>len) {
              offset= len;   // last valid pixel
            }
            addr=S_CURRLINE_PTR_INB(line_no)+(offset*wordsize);
            // for byte selection from word
            odd_byte=addr(0);
            // do word read always and then select later the right byte lane
            addr(0)=0;

#ifdef SYSC
            SysC_StreamDMA_Channel=line_no+3;
#endif
            retval=Mem(addr,2);
#ifdef SYSC
            SysC_StreamDMA_Channel=-1;
#endif
            break;

          case 3:  // constant
            odd_byte=0;
            retval=cfg(15,0); // REPLACEVALUE
            break;
          default: // constant for valid, 0 for invalid
            odd_byte=0;
            if ((offset<0)  || (offset > len)) {
              retval=0;
            }
            else {
              retval=cfg(15,0); // REPLACEVALUE
            }
          }

          // 8 bit alignment
          if (wordsize == 1) {
            if (odd_byte == 1) {
              retval(7,0)=retval(15,8);    // odd address in MSBs?
            }
            else {
              retval(15,8) = retval(7,0);  // even address in LSBs
            }
            if (cfg(29,28) == 1) {
              //BUFFERTYPE = 8bit MSB
              retval(7,0)=0;
            }
            else {  // S_BUFFERTYPE_INB == 2     =>  to LSB's
              retval(15,8)=0;
            }
          }
        }


        if (I_RPTCNT_INB(line_no) == 1) {
          if (lineend  == 0) { // stop incrementing after line end
            I_POS_INB(line_no) = pos + step;
            I_RPTCNT_INB(line_no) = cfg(19,18); //RPT
          }
        }
        else {
          I_RPTCNT_INB(line_no) = I_RPTCNT_INB(line_no) -1;
        }
        return retval;

      };
    }
    define (write) {
      action = func(unsigned line_no, bits<16> OUT) {
        return;
      };
    }
#endif // MAKEDOC
  }
#endif

#ifdef HASINALPHA
  // Stream Parameters for INAL ***************
#ifndef STREAM_IPS_IN_IPU
  define (reg=S_CHANNELS_INAL) {
    """
    StreamIF Host Register:
    Enabled Lines for channel INAL
    """;
    width = 3;
  }
#endif

  define (regfile=S_LINE_PTR_INAL) {
    """
    StreamIF Host Register:
    Line Start Addresses
    """;
    width = 32;
    size  = INPUT_STREAMS;
  }

  define (regfile=S_CURRLINE_PTR_INAL) {
    """
    StreamIF Host Register:
    Active Line Start Addresses (read only)
    """;
    width = 32;
    size  = INPUT_STREAMS;
  }

  define (regfile=S_LINELEN_INAL) {
    """
    StreamIF Host Register:
    Line length in pixels
    """;
    width = 16;   // unsigned value
    size  = INPUT_STREAMS;
    reset = 0xFFFF;
  }

  define (regfile=S_CURRLINELEN_INAL) {
    """
    StreamIF Host Register:
    Active line length in pixels (read only)
    """;
    width = 16;   // unsigned value
    size  = INPUT_STREAMS;
    reset = 0xFFFF;
  }

  define (regfile=S_CHCFG_INAL) {
    """
    StreamIF Host Register:
    Configuration for input streams at INAL of next line to be processed.
    """;
    width = 32;
    reset = 0x50000;
    size  = INPUT_STREAMS;
    define (field=REPLACEVALUE) {
      """
      Value to use for pixels outside the valid image area
      """;
      bits = (15,0);
    }
    define (field=STEP) {
      """
      Offset between two pixels being presented to the IPU engine

      + 0: 4 pixels offset
      + 1: 1 pixel offset (no pixel is skipped, all pixels are exercised)
      + 2: 2 pixels offset
      + 3: 3 pixels offset
      """;
      bits = (17,16);
    }
    define (field=RPT) {
      """
      How often a pixel is presented to the IPU engine

      + 0: 4 times
      + 1: 1 time (increment each pixel)
      + 2: 2 times
      + 3: 3 times
      """;
      bits = (19,18);
    }
    define (field=REPLACEMODE) {
      """
      Scheme for which pixels are getting the REPLAVEVALUE

      + 0: outside pixel = REPLACEVALUE, inside pixel = pixel value
      + 1: outside pixel = copy pixel from boundary, inside pixels = pixel value
      + 2: reserved
      + 3: outside pixel = REPLACEVALUE, inside pixels = REPLACEVALUE
      + 4: outside pixel = 0 , inside pixels = REPLACEVALUE
      """;
      // + 2: not implemented: outside pixel = repeat boundary
      // with width; inside pxel = pixel value
      bits = (22,20);
    }
    define (field=REVERSE) {
      """
      Do reverse scan of the line 

      + 0: normal scan (left to right)
      + 1: reverse scan (right to left)
      """;
      bits = (23,23);
    }
    define (field=REPLACEWIDTH) {
      """
      How many pixels are assumed at the beginning of the line outside
      the image. This might be used for filters with horizontal neighborhood.
      Example: 

      + 0: the image is not extended at the beginning of the line
           (first pixels is valid)
      + n: will present n more pixels at the beginning of the line.
           The (n+1)th pixel is the first valid pixel. The n first pixels
           are treated according to the REPLACEMODE
      """;
      bits = (26,24);
    }
    //define (field=TRANSFORM) {
    //  """
    //  Apply coordiante transformation mode
    //
    //  + 0: linear scan
    //  + 1: transformation
    //  """;
    //  bits = (27,27);
    //}
    define (field=BUFFERTYPE) {
      """
      Data type of memory buffer. The IPU will always get 16 bit values. 

      + 0: 16-bit
      + 1: 8-bit, data is put to MSBs
      + 2: 8-bit, data is put to LSBs
      """;
      bits = (29,28);
    }
  }

  define (regfile=S_CURRCHCFG_INAL) {
    """
    StreamIF Host Register:
    Active configuration status for input streams at INAL (read onyl)
    """;
    width = 32;
    size=INPUT_STREAMS;
    define (field=REPLAVEVALUE) {
      """
      Value to use for pixels outside the valid image area
      """;
      bits = (15,0);
    }
    define (field=STEP) {
      """
      Offset between two pixels being presented to the IPU engine

      + 0: 4 pixels offset
      + 1: 1 pixel offset (no pixel is skipped, all pixels are exercised)
      + 2: 2 pixels offset
      + 3: 3 pixels offset
      """;
      bits = (17,16);
    }
    define (field=RPT) {
      """
      How often a pixel is presented to the IPU engine

      + 0: 4 times
      + 1: 1 time (increment each pixel)
      + 2: 2 times
      + 3: 3 times
      """;
      bits = (19,18);
    }
    define (field=REPLACEMODE) {
      """
      Scheme for which pixels are getting the REPLAVEVALUE

      + 0: outside pixel = REPLACEVALUE, inside pixel = pixel value
      + 1: outside pixel = copy pixel from boundary, inside pixels = pixel value
      + 2: reserved
      + 3: outside pixel = REPLACEVALUE, inside pixels = REPLACEVALUE
      + 4: outside pixel = 0 , inside pixels = REPLACEVALUE
      """;
      //      + 2: not implemented: outside pixel = repeat boundary with width; inside pxel = pixel value
      bits = (22,20);
    }
    define (field=REVERSE) {
      """
      Do reverse scan of the line 

      + 0: normal scan (left to right)
      + 1: reverse scan (right to left)
      """;
      bits = (23,23);
    }
    define (field=REPLACEWIDTH) {
      """
      How many pixels are assumed at the beginning of the line outside
      the image. This might be used for filters with horizontal neighborhood.
      Example: 

      + 0: the image is not extended at the beginning of the line
           (first pixels is valid)
      + n: will present n more pixels at the beginning of the line.
           The (n+1)th pixel is the first valid pixel. The n first pixels
           are treated according to the REPLACEMODE
      """;
      bits = (26,24);
    }
    //define (field=TRANSFORM) {
    //  """
    //  Apply coordiante transformation mode
    //
    //  + 0: linear scan
    //  + 1: transformation
    //  """;
    //  bits = (27,27);
    //}
    define (field=BUFFERTYPE) {
      """
      Data type of memory buffer. The IPU will always get 16 bit values. 

      + 0: 16-bit
      + 1: 8-bit, data is put to MSBs
      + 2: 8-bit, data is put to LSBs
      """;
      bits = (29,28);
    }

#ifdef LOG_MORE
    define (read) {
      action = func (unsigned line_no) { return S_CURRCHCFG_INAL(line_no);};
    }
    define (write) {
      action = func (unsigned line_no, bits<32> val) {
        S_CURRCHCFG_INAL(line_no)=val;
        info(1,"INAL(",line_no,").REPEATVALUE = ",
             S_CURRCHCFG_INAL(line_no)(15,0));
        info(1,"INAL(",line_no,").STEP = ",
             S_CURRCHCFG_INAL(line_no)(17,16));
        info(1,"INAL(",line_no,").RPT = ",
             S_CURRCHCFG_INAL(line_no)(19,18));
        {
          static const char *mode[8] = {"0: outside const",
                                        "1: outside hold",
                                        "2: reseved",
                                        "3: repalce all w/ const",
                                        "4: inside const, outside 0",
                                        "5: reserved",
                                        "6: reserved",
                                        "7: reserved"};
          info(1,"INAL(",line_no,").REPLACEMODE = ",
               mode[S_CURRCHCFG_INAL(line_no)(22,20).uint32()]);
        }
        //switch (S_CURRCHCFG_INAL(line_no)(22,20).uint32()) {
        //case 0:
        //  info(1,"INAL(",line_no,").REPLACEMODE = ",
        //       "outside const");
        //  break;
        //case 1:
        //  info(1,"INAL(",line_no,").REPLACEMODE = ",
        //       "outside hold");
        //  break;
        //case 3:
        //  info(1,"INAL(",line_no,").REPLACEMODE = ",
        //       "repalce all w/ const");
        //  break;
        //case 4:
        //  info(1,"INAL(",line_no,").REPLACEMODE = ",
        //       "inside const, outside 0");
        //  break;
        //case 2:
        //default:
        //  info(1,"INAL(",line_no,").REPLACEMODE = ",
        //       "reserved");
        //  break;
        //}
        info(1,"INAL(",line_no,").REVERSE = ",
             S_CURRCHCFG_INAL(line_no)(23));
        info(1,"INAL(",line_no,").REPLACEWIDTH = ",
             S_CURRCHCFG_INAL(line_no)(26,24));
        //info(1,"INAL(",line_no,").TRANSFORM = ",
        //     S_CURRCHCFG_INAL(line_no)(27));
        //info(1,"INAL(",line_no,").BUFFERTYPE = ",
        //     S_CURRCHCFG_INAL(line_no)(29,28));
        {
          static const char *mode[4] = {"0: 16bpp",
                                        "1: 8bpp to MSB",
                                        "2: 8bpp to LSB",
                                        "3: reserved"};
          info(1,"INAL(",line_no,").BUFFERTYPE = ",
               mode[S_CURRCHCFG_INAL(line_no)(29,28).uint32()]);
        }
      };
    }
#endif
  }

  define (regfile=I_RPTCNT_INAL) {
    """
    Internal Register:
    counting the repeat status
    """;
    width = 2;
    reset = 1;
    size  = INPUT_STREAMS;
    define (read) {
      action = func (unsigned line_no) {
        if (I_RPTCNT_INAL(line_no) == 0) return 4;
        return I_RPTCNT_INAL(line_no);
      };
    }
  }

  define (regfile=I_POS_INAL) {
    """
    Internal Register:
    Current pixel position in the line
    """;
    width = 18; // internal signed value, 8 bit resolution
    size  = INPUT_STREAMS;
  }

  // do stream in for INAL
  define (regfile=P_INAL) {
    """
    Internal Register:
    Prefetch Register for INAL StreamDMA input. Once data is
    moved to INAL, the StreamDMA engine will autonomously fill
    the register with the next value from the line.
    """;
    width = 16; // internal signed value, 8 bit resolution
    size  = INPUT_STREAMS;
#ifndef MAKEDOC
    pseudo = true;
    define (read) {
      action = func(unsigned line_no) {
        bits<32> cfg;
        bits<16> retval;
        bits<32> addr;
        bits<1>  odd_byte;
        int len,pos,step;
        int lineend;
        int offset;
        int wordsize;

        cfg=S_CURRCHCFG_INAL(line_no);
        wordsize=(cfg(29,28) == 0)? 2 : 1; // BUFFERTYPE
        len=S_CURRLINELEN_INAL(line_no).uint32()-1;
        pos=I_POS_INAL(line_no).int32();
        step=cfg(17,16).uint32(); //STEP
        if (!step) step=4;
        lineend= (pos > len)? 1 : 0;

#ifndef SYSC
#ifdef LOG_MORE
         // unconfigured output address
        if ((cfg(22,20).uint32() < 3) &&
            (S_CURRLINE_PTR_INAL(line_no).uint32() < 0x10000)) {
          error(1,
                "\n********************\n",
                "ERROR: invalid address INAL_PTR(",
                line_no,") = ",S_CURRLINE_PTR_INAL(line_no),
                "\n********************\n");
        }
#endif
#endif

        if (S_EMUMEM == 1) {  // do not implemnt this branch in HW!!!
          retval=I_POS_INAL(line_no);
        }
        else {

          offset=pos;
          if (cfg(23)==1) {  // REVERSE
            offset=len - offset;
          };

          switch (cfg(22,20).uint32() ) { //REPLACEMODE
          case 0:   // normal with pad to constant (hold order 0)
            if ((offset<0)  || (offset > len)) {
              odd_byte=0;
              retval = cfg(15,0); // REPLACEVALUE
            }
            else {
              addr=S_CURRLINE_PTR_INAL(line_no)+(offset*wordsize);
              // for byte selection from word
              odd_byte=addr(0);
              // do word read always and then select later the right byte lane
              addr(0)=0;
#ifdef HASINALPHASTREAM
#ifdef SYSC
              SysC_StreamDMA_Channel=line_no+6;
#endif
              retval=Mem(addr,2);
#ifdef SYSC
              SysC_StreamDMA_Channel=-1;
#endif
#else
              retval=0xffff;
#endif
            }
            break;
          case 1:  // normal mode, pad with nearest valid pixel (hold order 1)
            if (offset<0) {
              offset=0;
            }
            if (offset>len) {
              offset= len;   // last valid pixel
            }
            addr=S_CURRLINE_PTR_INAL(line_no)+(offset*wordsize);
            // for byte selection from word
            odd_byte=addr(0);
            // do word read always and then select later the right byte lane
            addr(0)=0;

#ifdef HASINALPHASTREAM
#ifdef SYSC
            SysC_StreamDMA_Channel=line_no+6;
#endif
            retval=Mem(addr,2);
#ifdef SYSC
            SysC_StreamDMA_Channel=-1;
#endif
#else
            retval=0xffff;
#endif
            break;

          case 3:  // constant
            odd_byte=0;
            retval=cfg(15,0); // REPLACEVALUE
            break;
          default: // constant for valid, 0 for invalid
            odd_byte=0;
            if ((offset<0)  || (offset > len)) {
              retval=0;
            }
            else {
              retval=cfg(15,0); // REPLACEVALUE
            }
          }

          // 8 bit alignment
          if (wordsize == 1) {
            if (odd_byte == 1) {
              retval(7,0)=retval(15,8);    // odd address in MSBs?
            }
            else {
              retval(15,8) = retval(7,0);  // even address in LSBs
            }
            if (cfg(29,28) == 1) {
              //BUFFERTYPE = 8bit MSB
              retval(7,0)=0;
            }
            else {  //BUFFERTYPE = 8bit LSB
              retval(15,8)=0;
            }
          }
        }

        if (I_RPTCNT_INAL(line_no) == 1) {
          if (lineend  == 0) { // stop incrementing after line end
            I_POS_INAL(line_no) = pos + step;
            I_RPTCNT_INAL(line_no) = cfg(19,18); //RPT
          }
        }
        else {
          I_RPTCNT_INAL(line_no) = I_RPTCNT_INAL(line_no) -1;
        }
        return retval;

      };
    }
    define (write) {
      action = func(unsigned line_no, bits<16> OUT) {
        return;
      };
    }
#endif // MAKEDOC
  }
#endif

  // Stream Parameters for OUT ***************
#ifndef STREAM_IPS_IN_IPU
  define (reg=S_CHANNELS_OUT) {
    """
    StreamIF Host Register:
    Enabled Lines for channel OUT
    """;
    width = 3;
  }
#endif

  // from output registers
  define (regfile=S_LINE_PTR_OUT) {
    """
    StreamIF Host Register:
    Line Start Addresses
    """;
    width = 32;
    size=OUTPUT_STREAMS;
  }

  define (regfile=S_CURRLINE_PTR_OUT) {
    """
    StreamIF Host Register:
    Active Line Start Addresses
    """;
    width = 32;
    size  = OUTPUT_STREAMS;
    define (write) {
      action = func (unsigned line_no,bits<32> val) {
        // force 3 LSBs to 0: 64 bit alligned addresses
        S_CURRLINE_PTR_OUT(line_no) = val.uint32() & 0xfffffff8;
        //warning(1,"testwarning:",hex,showbase,val);
        if (val(2,0) != 0) {
          error(1,
                "\n********************\n",
                "ERROR: unaligned address PTR_OUT(",dec,
                line_no,") = ",hex,showbase,val,
                "\n********************\n");
        }
      };
    }
  }

  define (regfile=S_LINELEN_OUT) {
    """
    StreamIF Host Register:
    Line length in pixels
    """;
    width = 16;   // unsigned value
    size  = OUTPUT_STREAMS;
    reset = 0xFFFF;
  }

  define (regfile=S_CURRLINELEN_OUT) {
    """
    StreamIF Host Register:
    Active line length in pixels (read only)
    """;
    width = 16;   // unsigned value
    size  = OUTPUT_STREAMS;
    reset = 0xFFFF;
  }

  define (regfile=S_CHCFG_OUT) {
    """
    StreamIF Host Register:
    Configuration for output streams
    """;
    width = 32;
    reset = 0x00000;
    size  = OUTPUT_STREAMS;
    define (field=SKIP) {
      """
      Skip pixel when writing this channel SKIP times

      + 0: 0 pixels (store evrey pixel)
      + 1: 1 pixel  (store every second pixel)
      + 2: 2 pixels (store every 3rd pixel)
      + 3: 3 pixels (store every 4th pixel)
      """;
      bits = (17,16);
    }
    define (field=BUFFERTYPE) {
      """
      Data type of memory buffer.

      + 0: 16-bit
      + 1: 8-bit, data from MSBs
      + 2: 8-bit, data from LSBs
      """;
      bits = (29,28);
    }
#ifdef LOG_MORE
    define (read) {
      action = func (unsigned line_no) { return S_CHCFG_OUT(line_no);};
    }
    define (write) {
      action = func (unsigned line_no, bits<32> val) {
        S_CHCFG_OUT(line_no)=val;
        info(1,"OUT(",line_no,").SKIP = ",
             S_CHCFG_OUT(line_no)(17,16));
        //info(1,"OUT(",line_no,").BUFFERTYPE = ",
        //     S_CHCFG_OUT(line_no)(29,28));
        {
          static const char *mode[4] = {"0: 16bpp",
                                        "1: 8bpp from MSB",
                                        "2: 8bpp from LSB",
                                        "3: reserved"};
          info(1,"OUT(",line_no,").BUFFERTYPE = ",
               mode[S_CHCFG_OUT(line_no)(29,28).uint32()]);
        }
      };
    }
#endif
  }

  define (regfile=S_CURRCHCFG_OUT) {
    """
    StreamIF Host Register:
    Active configuration for output streams
    """;
    width = 32;
    size  = OUTPUT_STREAMS;
    define (field=SKIP) {
      """
      Skip pixel when writing this channel SKIP times

      + 0: 0 pixels (store evrey pixel)
      + 1: 1 pixel  (store every second pixel)
      + 2: 2 pixels (store every 3rd pixel)
      + 3: 3 pixels (store every 4th pixel)
      """;
      bits = (17,16);
    }
    define (field=BUFFERTYPE) {
      """
      Data type of memory buffer.

      + 0: 16-bit
      + 1: 8-bit, data from MSBs
      + 2: 8-bit, data from LSBs
      """;
      bits = (29,28);
    }
#ifdef LOG_MORE
    define (read) {
      action = func (unsigned line_no) { return S_CURRCHCFG_OUT(line_no);};
    }
    define (write) {
      action = func (unsigned line_no, bits<32> val) {
        S_CURRCHCFG_OUT(line_no)=val;
        info(1,"OUT(",line_no,").SKIP = ",
             S_CURRCHCFG_OUT(line_no)(17,16));
        //info(1,"OUT(",line_no,").BUFFERTYPE = ",
        //     S_CURRCHCFG_OUT(line_no)(29,28));
        {
          static const char *mode[4] = {"0: 16bpp",
                                        "1: 8bpp from MSB",
                                        "2: 8bpp from LSB",
                                        "3: reserved"};
          info(1,"OUT(",line_no,").BUFFERTYPE = ",
               mode[S_CURRCHCFG_OUT(line_no)(29,28).uint32()]);
        }
      };
    }
#endif
  }

  define (regfile=I_POS_OUT) {
    """
    Internal Register:
    Current byte position in the line
    """;
    width = 18; // internal signed value, 8 bit resolution
    size=OUTPUT_STREAMS;
  }

  define (regfile=I_SKIPCNT_OUT) {
    """
    Internal Register:
    counting the skip status
    """;
    width = 2;
    reset=0;
    size=5;
  }

  // do stream out
  define (regfile=O) {
    """
    Internal Register:
    StreamDMA output interface. Once data is
    moved from OUT, the StreamDMA engine will autonomously write
    the register back to the memory (buffering 64 bits). 
    """;
    width = 16; // internal signed value, 8 bit resolution
    size=OUTPUT_STREAMS;
#ifndef MAKEDOC
    pseudo = true;
    define (read) {
      action = func(unsigned line_no) {
        return 0;
      };
    }
    define (write) {
      action = func(unsigned line_no, bits<16> val) {
        bits<32> cfg;
        bits<32> addr;
        int offset;
        int wordsize;

        cfg=S_CURRCHCFG_OUT(line_no);
        wordsize=(cfg(29,28) == 0)? 2 : 1; // BUFFERTYPE
        offset=I_POS_OUT(line_no).int32();

        if (offset >= (int)(S_CURRLINELEN_OUT(line_no).uint32())) return;

        if (I_SKIPCNT_OUT(line_no) == 0) {

          // write is doing byte or short writes!!
          addr=S_CURRLINE_PTR_OUT(line_no)+(offset*wordsize);
#ifndef SYSC
          if (addr.uint32() < 0x10000) { // unconfigured output address
            error(1,
                  "\n********************\n",
                  "ERROR: invalid address OUT_PTR(",
                  line_no,") = ",S_CURRLINE_PTR_OUT(line_no),
                  "\n********************\n");
          }
#endif

#ifdef SYSC
          SysC_StreamDMA_Channel=line_no;
#endif
          if (wordsize == 1) {
            //if (odd_byte ==1) {
            //  val(7,0)=val(15,8);    // odd address in MSBs?
            //}
            //else {
            //  val(15,8) = val(7,0);  // even address in LSBs
            //}
            if (cfg(29,28) == 1) {
              //BUFFERTYPE = 8bit MSB
              Mem(addr,1)= val(15,8);
            }
            else {  //BUFFERTYPE = 8bit LSB
              Mem(addr,1)= val(7,0);
            }
          }
          else {
            Mem(addr,2)=val;
          }
#ifdef SYSC
          SysC_StreamDMA_Channel=-1;
#endif

          I_POS_OUT(line_no) = I_POS_OUT(line_no)+1;
          if (cfg(17,16) != 0) {  // SKIP, condition not needed for RTL, this should only avoid log in trace if feature is disabled
            I_SKIPCNT_OUT(line_no)=cfg(17,16);
          }
        }
        else {
          if (cfg(17,16) != 0) {  // Skip condition not needed for RTL, this should only avoid log in trace if feature is disabled
            I_SKIPCNT_OUT(line_no)=I_SKIPCNT_OUT(line_no) -1;
          }
        }
      };
    }
#endif // MAKEDOC
  }

  // ***********************************************************************
  // Register IPS address mapping
  // ***********************************************************************
#ifdef STREAM_IPS_IN_IPU
  defmod (regfile=H_IPS) {
    size = 192;
    // StreamDMA
    //define (entry= 0x40)  { reg = S_CFG; }
    define (entry= 0x41)  { reg = S_LINELEN_INA(0); }
    define (entry= 0x42)  { reg = S_CHCFG_INA(0); }
    define (entry= 0x43)  { reg = S_LINE_PTR_INA(0); }
    define (entry= 0x44)  { reg = S_LINELEN_INA(1); }
    define (entry= 0x45)  { reg = S_CHCFG_INA(1); }
    define (entry= 0x46)  { reg = S_LINE_PTR_INA(1); }
    define (entry= 0x47)  { reg = S_LINELEN_INA(2); }
    define (entry= 0x48)  { reg = S_CHCFG_INA(2); }
    define (entry= 0x49)  { reg = S_LINE_PTR_INA(2); }
#ifdef HASINB
    define (entry= 0x51)  { reg = S_LINELEN_INB(0); }
    define (entry= 0x52)  { reg = S_CHCFG_INB(0); }
    define (entry= 0x53)  { reg = S_LINE_PTR_INB(0); }
    define (entry= 0x54)  { reg = S_LINELEN_INB(1); }
    define (entry= 0x55)  { reg = S_CHCFG_INB(1); }
    define (entry= 0x56)  { reg = S_LINE_PTR_INB(1); }
    define (entry= 0x57)  { reg = S_LINELEN_INB(2); }
    define (entry= 0x58)  { reg = S_CHCFG_INB(2); }
    define (entry= 0x59)  { reg = S_LINE_PTR_INB(2); }
#endif
#ifdef HASINALPHA
    define (entry= 0x61)  { reg = S_LINELEN_INAL(0); }
    define (entry= 0x62)  { reg = S_CHCFG_INAL(0); }
    define (entry= 0x63)  { reg = S_LINE_PTR_INAL(0); }
    define (entry= 0x64)  { reg = S_LINELEN_INAL(1); }
    define (entry= 0x65)  { reg = S_CHCFG_INAL(1); }
    define (entry= 0x66)  { reg = S_LINE_PTR_INAL(1); }
    define (entry= 0x67)  { reg = S_LINELEN_INAL(2); }
    define (entry= 0x68)  { reg = S_CHCFG_INAL(2); }
    define (entry= 0x69)  { reg = S_LINE_PTR_INAL(2); }
#endif
    define (entry= 0x71)  { reg = S_LINELEN_OUT(0); }
    define (entry= 0x72)  { reg = S_CHCFG_OUT(0); }
    define (entry= 0x73)  { reg = S_LINE_PTR_OUT(0); }
#ifdef OUTPUT_STREAM1
    define (entry= 0x74)  { reg = S_LINELEN_OUT(1); }
    define (entry= 0x75)  { reg = S_CHCFG_OUT(1); }
    define (entry= 0x76)  { reg = S_LINE_PTR_OUT(1); }
#endif
#ifdef OUTPUT_STREAM2
    define (entry= 0x77)  { reg = S_LINELEN_OUT(2); }
    define (entry= 0x78)  { reg = S_CHCFG_OUT(2); }
    define (entry= 0x79)  { reg = S_LINE_PTR_OUT(2); }
#endif
#ifdef OUTPUT_STREAM3
    define (entry= 0x7a)  { reg = S_LINELEN_OUT(3); }
    define (entry= 0x7b)  { reg = S_CHCFG_OUT(3); }
    define (entry= 0x7c)  { reg = S_LINE_PTR_OUT(3); }
#endif

    define (entry= 0x81)  { reg = S_CURRLINELEN_INA(0); }
    define (entry= 0x82)  { reg = S_CURRCHCFG_INA(0); }
    define (entry= 0x83)  { reg = S_CURRLINE_PTR_INA(0); }
    define (entry= 0x84)  { reg = S_CURRLINELEN_INA(1); }
    define (entry= 0x85)  { reg = S_CURRCHCFG_INA(1); }
    define (entry= 0x86)  { reg = S_CURRLINE_PTR_INA(1); }
    define (entry= 0x87)  { reg = S_CURRLINELEN_INA(2); }
    define (entry= 0x88)  { reg = S_CURRCHCFG_INA(2); }
    define (entry= 0x89)  { reg = S_CURRLINE_PTR_INA(2); }
#ifdef HASINB
    define (entry= 0x91)  { reg = S_CURRLINELEN_INB(0); }
    define (entry= 0x92)  { reg = S_CURRCHCFG_INB(0); }
    define (entry= 0x93)  { reg = S_CURRLINE_PTR_INB(0); }
    define (entry= 0x94)  { reg = S_CURRLINELEN_INB(1); }
    define (entry= 0x95)  { reg = S_CURRCHCFG_INB(1); }
    define (entry= 0x96)  { reg = S_CURRLINE_PTR_INB(1); }
    define (entry= 0x97)  { reg = S_CURRLINELEN_INB(2); }
    define (entry= 0x98)  { reg = S_CURRCHCFG_INB(2); }
    define (entry= 0x99)  { reg = S_CURRLINE_PTR_INB(2); }
#endif
#ifdef HASINALPHA
    define (entry= 0xa1)  { reg = S_CURRLINELEN_INAL(0); }
    define (entry= 0xa2)  { reg = S_CURRCHCFG_INAL(0); }
    define (entry= 0xa3)  { reg = S_CURRLINE_PTR_INAL(0); }
    define (entry= 0xa4)  { reg = S_CURRLINELEN_INAL(1); }
    define (entry= 0xa5)  { reg = S_CURRCHCFG_INAL(1); }
    define (entry= 0xa6)  { reg = S_CURRLINE_PTR_INAL(1); }
    define (entry= 0xa7)  { reg = S_CURRLINELEN_INAL(2); }
    define (entry= 0xa8)  { reg = S_CURRCHCFG_INAL(2); }
    define (entry= 0xa9)  { reg = S_CURRLINE_PTR_INAL(2); }
#endif

    define (entry= 0xb1)  { reg = S_CURRLINELEN_OUT(0); }
    define (entry= 0xb2)  { reg = S_CURRCHCFG_OUT(0); }
    define (entry= 0xb3)  { reg = S_CURRLINE_PTR_OUT(0); }
#ifdef OUTPUT_STREAM1
    define (entry= 0xb4)  { reg = S_CURRLINELEN_OUT(1); }
    define (entry= 0xb5)  { reg = S_CURRCHCFG_OUT(1); }
    define (entry= 0xb6)  { reg = S_CURRLINE_PTR_OUT(1); }
#endif
#ifdef OUTPUT_STREAM2
    define (entry= 0xb7)  { reg = S_CURRLINELEN_OUT(2); }
    define (entry= 0xb8)  { reg = S_CURRCHCFG_OUT(2); }
    define (entry= 0xb9)  { reg = S_CURRLINE_PTR_OUT(2); }
#endif
#ifdef OUTPUT_STREAM3
    define (entry= 0xba)  { reg = S_CURRLINELEN_OUT(3); }
    define (entry= 0xbb)  { reg = S_CURRCHCFG_OUT(3); }
    define (entry= 0xbc)  { reg = S_CURRLINE_PTR_OUT(3); }
#endif
  }

#else // STREAM_IPS_IN_IPU is not defined

  define (regfile=H_IPS_SDMA) {
    """
    IPS peripheral register (Host registers) address mapping
    for StreamDMA units
    """;
    size = 64;
    width = 32;
    // StreamDMA
    define (entry= 0x00)  { reg = S_CFG; }
    define (entry= 0x01)  { reg = S_LINELEN_INA; }
    define (entry= 0x04)  { reg = S_CHCFG_INA; }
    define (entry= 0x07)  { reg = S_LINE_PTR_INA; }
#ifdef HASINB
    define (entry= 0x11)  { reg = S_LINELEN_INB; }
    define (entry= 0x14)  { reg = S_CHCFG_INB; }
    define (entry= 0x17)  { reg = S_LINE_PTR_INB; }
#endif
#ifdef HASINALPHA
    define (entry= 0x21)  { reg = S_LINELEN_INAL; }
    define (entry= 0x24)  { reg = S_CHCFG_INAL; }
    define (entry= 0x27)  { reg = S_LINE_PTR_INAL; }
#endif
    define (entry= 0x31)  { reg = S_LINELEN_OUT; }
    define (entry= 0x35)  { reg = S_CHCFG_OUT; }
    define (entry= 0x39)  { reg = S_LINE_PTR_OUT; }
  }

#endif // STREAM_IPS_IN_IPU

}
